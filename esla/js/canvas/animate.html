<!DOCTYPE html>
<html>
<head>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
</head>	
<body onload = "init()"> 
<!-- == page == -->




<select id="colorSelection" onchange="colorChanged()">
	<option> black </option>
	<option> blue </option>
	<option> red </option>
</select> 

<canvas id="myCanvas" width="1500" height="700"></canvas>

<h1 id = "firstHeader"> Hello lord </h1> 

<!--   == script == --> 
<script>

//     == future == 


// * integrate (in a very basic manner) to a django application 
 
// * data strcture for multiple curves (frame or image) 

// * data strcture for multiple frames (clip) , then multiple clips (library?) 

// * zooming capability 

// * export to animated image? 

// * menues and other options (lines, colors, gradients... ) 


// == init == 
function init() {
	
// == global namespace == 
g = {
	
	path:[], 
	 	
	jointRad:3,
	chosenRad:4,  
	controlRad:2, 
	
	selectRad:15, 
	
	selectedPoint:-1,   
	draggedPoint:-1, 

	cx:0, // the place of the upper left corner of the screen in the logical plane 
	cy:0, // (the one which is used in the data structure) 
	factor:1, // the zoom factor of the display 
    df:1.2,   //  zoom factor's change ratio (for each wheel move) 
    
	isClosed:false, 
} 
	// ---- 
	
	colorChanged();

	var canvas = document.getElementById('myCanvas');

	canvas.addEventListener("mousedown", mouseDown ,false); 
	canvas.addEventListener("mouseup", mouseUp ,false); 
	canvas.addEventListener("mousemove", mouseMove ,false); 
	canvas.addEventListener("mousewheel",mouseWheel,false);

	clearCanvas();
}


// == redraw() == 

function redraw() {
	clearCanvas(); // should be changed to delete only current curve  
	
	if (g.path.length == 0) {
		return; 
	}

	if(g.isClosed) {
		redrawClosed();
	} else {
		redrawOpen(); 
	}
	
}

// == redrawOpen == 
function redrawOpen() {
	var last = g.path.length-1; 
	
	for (i=0; i <= last; i+=3)  {
		var x0 = g.path[i][0], y0 = g.path[i][1],
		      x1, y1, 
		      x2,y2,
		      x3,y3; 
		if(i < last) {
            x1 = g.path[i+1][0], y1 = g.path[i+1][1],
            x2 = g.path[i+2][0], y2 = g.path[i+2][1],
            x3 = g.path[i+3][0], y3 = g.path[i+3][1]; 

			curve(x0,y0, x1,y1, x2,y2 ,x3,y3);
		}
		if (i == g.selectedPoint) {
			if(i > 0) {
				var xp = g.path[i-1][0], yp = g.path[i-1][1]; 
				line(x0,y0,xp,yp);  
				circle(xp,yp,g.controlRad,"gray");
			}	
			if (i < last) {
			    line(x0,y0,x1,y1); 
	            circle(x1,y1,g.controlRad,"gray"); 		 
			 }
			circle(x0,y0,g.chosenRad,"cyan"); 
		} else {
		  circle(x0,y0,g.jointRad,"gray"); 
		}
	}
} 

// == redrawClosed == 
function redrawClosed() {
	var n = g.path.length; 
	
	for (i=0; i < n; i+=3)  {
		var x0 = g.path[i][0], y0 = g.path[i][1],
              x1 = g.path[i+1][0], y1 = g.path[i+1][1],
              x2 = g.path[i+2][0], y2 = g.path[i+2][1],
              x3 = g.path[(i+3)%n][0], y3 = g.path[(i+3)%n][1]; 

		curve(x0,y0, x1,y1, x2,y2 ,x3,y3);
		if (i == g.selectedPoint) {
            var xp = g.path[(i+n-1)%n][0], yp = g.path[(i+n-1)%n][1]; // the '+n' is due to the fact that in js, is the reminder operator not the modulus (boo) 
            line(x0,y0,xp,yp);  
            circle(xp,yp,g.controlRad,"gray");
            line(x0,y0,x1,y1); 
            circle(x1,y1,g.controlRad,"gray"); 		 
            circle(x0,y0,g.chosenRad,"cyan"); 
		} else {
		  circle(x0,y0,g.jointRad,"gray"); 
		}
	}
}

// == clearCanvas == 
function clearCanvas() {
	var canvas = document.getElementById('myCanvas');
	var context = canvas.getContext('2d');

	context.beginPath() ; // this is necessary due to some behaivour of canvas that I do not understand. Without this, the last 
	                                // stroke doesn't get deleted 
	context.clearRect(0, 0, canvas.width, canvas.height);

	context.rect(0,0,canvas.width, canvas.height);
	context.stroke();

}

function distance(x1,y1,x2,y2) {
	return Math.sqrt(Math.pow((x1-x2),2)+Math.pow((y1-y2),2) ); 
}


// == mouseWheel == 
function mouseWheel(e) {

    x = canvas2dataX(e.offsetX);   y = canvas2dataY(e.offsetY); 
    
    if(e.wheelDelta > 0) 
        f = g.df
     else 
        f = 1/g.df;  
          
     g.factor *= f; 
    
    g.cx = x + (g.cx - x) / f; 
    g.cy = y + (g.cy - y) / f; 

    redraw(); 
}



// == mouse press handle == 
function mouseDown(e) {
	// check for joint point selection 
	for(i=0; i<g.path.length; i+=3) 
		if ( distance(e.offsetX, e.offsetY, data2canvasX(g.path[i][0]), data2canvasY(g.path[i][1])) < g.selectRad ) {
			g.selectedPoint = i; 
			g.draggedPoint = i; 
			redraw(); 
			return; 
		}
	 
	 if(g.selectedPoint != -1) { // selection is on : search for drag 
		var idxs = [];  // indexs of the selected point's control points 
		if(!g.isClosed) {
			if (g.selectedPoint > 0)
				idxs.push(g.selectedPoint -1);
			if ( g.selectedPoint < g.path.length-1)
				idxs.push(g.selectedPoint + 1); 
		} else {
			n = g.path.length; 
			idxs.push( (g.selectedPoint - 1+n)%n); 
			idxs.push( (g.selectedPoint + 1)%n); 
		}
		for(k=0; k <= idxs.length; ++k) { 
			i = idxs[k]; 
			if ( distance(e.offsetX, e.offsetY,
			              data2canvasX(g.path[i][0]), data2canvasY(g.path[i][1])
			             ) < g.selectRad ) {
				g.draggedPoint = i; 
	  			return; 
			}
		}
	}
	
    if(g.isClosed) 
        return; 
 	
	g.selectedPoint = -1; 
	
	var	n = g.path.length-1,
			x3 = e.offsetX, y3 = e.offsetY; 
				
	if (n < 0) { // first point in path 
		g.path = [[canvas2dataX(x3),canvas2dataY(y3)]]; 
		redraw(); 
		return; 
	}

  	var x0 = g.path[n][0], y0 = g.path[n][1], 
   		  xm = (x3-x0)/3, ym =  (y3-y0)/3, 
   		  x1 = x0+xm, y1 = y0+ym; 
	
	if (n>0) { // if the path alreay contains a segment
		var xq = 2*x0-g.path[n-1][0], yq =2*y0 - g.path[n-1][1]; 
		x1 = (x1+xq)/2; // fix (x1,y1) to reflect last conrol point of the last sgement 
		y1 = (y1+yq)/2; 
	
		g.path[n-1][0] = canvas2dataX(2*x0-x1); // also fix that last control point 
		g.path[n-1][1] = canvas2dataY(2*y0-y1); // to be symetric to our new (x1,y1) 
	}
	
	g.path.push([canvas2dataX(x1),canvas2dataY(y1)]); 
	
	var  x2 = x0+xm*2, y2 = y0+ym*2;   

	g.path.push([canvas2dataX(x2),canvas2dataY(y2)]); 
	
	g.path.push([canvas2dataX(x3),canvas2dataY(y3)]);
	
	redraw();  
}

// == changePoint == 
function changePoint(idx,xv,yv) {
	g.path[idx][0] = canvas2dataX(data2canvasX(g.path[idx][0])+xv); 
	g.path[idx][1] = canvas2dataY(data2canvasY(g.path[idx][1])+yv); 
}

// == mouseMove == 
function mouseMove(e) {
	if (g.draggedPoint == -1)
		return; 
		
	var dx = e.offsetX - data2canvasX(g.path[g.draggedPoint][0]), 
	    dy = e.offsetY - data2canvasY(g.path[g.draggedPoint][1]),  
		last = g.path.length-1;
	
	g.path[g.draggedPoint] =  [ canvas2dataX(e.offsetX), canvas2dataY(e.offsetY) ]; 

	var pointType = g.draggedPoint % 3; 
   
    if(!g.isClosed) {
	    if(pointType ==0) { // drag joint point : control g.path escort 
		    if (g.draggedPoint < last) {
				changePoint(g.draggedPoint+1,dx,dy); 
		    } 
		    if (g.draggedPoint > 0) {
				changePoint(g.draggedPoint-1,dx,dy); 
		    } 
	    } else { // drag control point: other control reverse mirror  
		    var otherControl = g.draggedPoint+(pointType-1)*4-2; // type==1 --> -2, type ==2 --> +2   
		    if(otherControl>0 && otherControl <last) {
			    changePoint(otherControl,-dx,-dy); 
		    }	
	    }
    } else {
        var n = g.path.length; 
	    if(pointType ==0) { // drag joint point : control g.path escort 
			changePoint((g.draggedPoint+1)%n,dx,dy); 
			changePoint((g.draggedPoint-1+n)%n,dx,dy); 	
	    } else { // drag control point: other control reverse mirror  
		    var otherControl = (g.draggedPoint+(pointType-1)*4-2 +n)%n;  
		    changePoint(otherControl,-dx,-dy); 	    
	    }
    }	
	redraw();  
} 


// == mouseUp == 
function mouseUp(e) {
	var last = g.path.length-1; 
	if (last <= 0) {
		g.draggedPoint = -1; 
		return; 
	}
    if 	( g.draggedPoint == last && distance(e.offsetX,e.offsetY, data2canvasX(g.path[0][0]), data2canvasY(g.path[0][1])) < g.selectRad 
    		      ||
    	       g.draggedPoint == 0 && distance(e.offsetX,e.offsetY, data2canvasX(g.path[last][0]), data2canvasY(g.path[last][1])) < g.selectRad   )  { 
		g.isClosed = true; 
		g.path.splice(last,1); // delete last element
		var x3 = g.path[0][0],  y3 = g.path[0][1], 
			  x2 = g.path[last-1][0], y2 = g.path[last-1][1];  
		
		var xp = 2*x3 - g.path[1][0], yp = 2*y3 - g.path[1][1];
		x2 = (x2+xp)/2; 
		y2 = (y2+yp)/2; 
		
		g.path[last-1][0] = canvas2dataX(x2); 
		g.path[last-1][1] = canvas2dataY(y2); 
	    g.path[1][0] = canvas2dataX(2*x3 - x2); 
	 	g.path[1][1] = canvas2dataY(2*y3 - y2); 
		
		redraw(); 
	}
	g.draggedPoint = -1; 
}

// == curve == 
function curve(x1,y1,x2,y2,x3,y3,x4,y4) {
	x1 = data2canvasX(x1);	 	 y1 = data2canvasY(y1);
	x2 = data2canvasX(x2);	 y2 = data2canvasY(y2);
	x3 = data2canvasX(x3); 	 y3 = data2canvasY(y3);
	x4 = data2canvasX(x4); 	 y4 = data2canvasY(y4);

	var canvas = document.getElementById('myCanvas');
	var context = canvas.getContext('2d');

	context.beginPath();
  	context.moveTo(x1,  y1);
  	context.bezierCurveTo(x2, y2, x3, y3, x4, y4);
  	context.lineWidth = 3;
  	context.strokeStyle = color; 
	context.stroke();
}

// == line == 
function line(x1,y1,x2,y2) {
	x1 = data2canvasX(x1);	 	 y1 = data2canvasY(y1);
	x2 = data2canvasX(x2);	 y2 = data2canvasY(y2);

	var canvas = document.getElementById('myCanvas');
	var context = canvas.getContext('2d');

	context.beginPath();
  	context.moveTo(x1,  y1);
	context.lineTo(x2,y2);
	context.strokeStyle = "gray"; 
	context.stroke();
}

// == circle == 
function circle(x,y,r,c) {
	x = data2canvasX(x);	 	 y = data2canvasY(y);
	// r *= g.factor; 
	var canvas = document.getElementById('myCanvas');
	var context = canvas.getContext('2d');

	context.beginPath();
	context.arc(x, y, r, 0, 2 * Math.PI, false);
	context.fillStyle = c;
	context.fill();
	context.lineWidth = 2;
	context.strokeStyle = 'black';
	context.stroke();
}

// == debugPrint == 
function debugPrint(str) {
	document.getElementById("firstHeader").innerHTML += str +" "; 
}

// == translations: == 

//  == data2canvasX ==
function data2canvasX(x) {
	return (x-g.cx)*g.factor; 
}

//  == canvas2dataX ==
function canvas2dataX(x) {
	return x / g.factor + g.cx; 
}

//  == data2canvasY ==
function data2canvasY(y) {
	return (y-g.cy)*g.factor; 
}

//  == canvas2dataY ==
function canvas2dataY(y) {
	return y / g.factor + g.cy; 
}

// == cloneArray ==
function cloneArray(ar) {
	
	if (typeof ar.length == 'undefined') {
		return ar; 
	}

	var r = []; 
	for (var i=0; i<ar.length; ++i)
		r.push(cloneArray(ar[i]));  
	return r; 
}

// == misc == 
function colorChanged() {
	var dropList = document.getElementById("colorSelection"); 
	color = ""+dropList.options[dropList.selectedIndex].text; 
	
	document.getElementById("firstHeader").innerHTML = color; 
	redraw();
} 
</script> 

</body> 
</html> 

