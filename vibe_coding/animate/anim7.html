<!DOCTYPE html>
<html lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>עורך אנימציית עקומות בזייה - גרסה משופרת</title>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" xintegrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* General page styles */
        body {
            font-family: 'Open Sans', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding-top: 0;
            background-color: #f8f9fa; /* Lighter background */
            color: #343a40; /* Darker text for better contrast */
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Toolbar styles */
        #toolbar {
            width: 100%;
            background-color: #ffffff; /* White toolbar */
            padding: 12px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.08);
            display: flex;
            align-items: center;
            margin-bottom: 25px;
            direction: rtl; /* Right-to-left for Hebrew */
            flex-wrap: wrap;
            border-bottom: 1px solid #e0e0e0;
        }
        .toolbar-group {
            display: flex;
            align-items: center;
            margin-left: 15px; /* Space between groups */
        }
        .toolbar-group:first-child {
            margin-left: 0;
        }


        .toolbar-button, .nav-button, .file-input-label {
            background-color: #007bff; /* Primary blue */
            color: white;
            border: none;
            padding: 9px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-flex; /* For aligning icon and text */
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            margin-left: 6px; /* Default spacing for buttons within a group */
            margin-bottom: 5px;
            cursor: pointer;
            border-radius: 6px;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease;
        }
        
         .toolbar-group .file-input-label { /* Add margin to the left of the upload button */
            margin-left: 12px; /* Increased spacing between save and upload */
        }


        .toolbar-button i, .nav-button i, .file-input-label i {
            margin-right: 6px; /* Space between icon and text (visual left in RTL) */
        }
        .toolbar-button i.fa-fw, .nav-button i.fa-fw, .file-input-label i.fa-fw { /* Fixed width icons */
             margin-right: 0;
             font-size: 1.1em;
        }


        .toolbar-group > *:first-child {
             margin-left: 0; /* No margin for the first button in a group */
        }

        .nav-button {
            font-size: 16px;
            padding: 8px 12px;
        }
        .file-input-label input[type="file"] {
            display: none;
        }

        .toolbar-button:hover, .nav-button:hover, .file-input-label:hover {
            background-color: #0056b3; /* Darker blue on hover for default buttons */
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }
        .toolbar-button:active, .nav-button:active, .file-input-label:active {
            transform: translateY(1px);
        }

        .toolbar-button.active {
            background-color: #28a745; /* Green for active state (e.g., Edit) */
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
         .toolbar-button.active:hover {
            background-color: #1e7e34; 
        }
        
        #playMovieButton { /* Specific style for play button */
            background-color: #FF6961; /* Pastel Red */
            color: white; 
        }
        #playMovieButton:hover {
            background-color: #FF473A; /* Darker Pastel Red on hover */
        }

        .toolbar-button.playing { /* This class is added by JS when playing */
            background-color: #dc3545 !important; /* Red for playing state (Stop button) - important to override base */
            color: white !important;
        }
         .toolbar-button.playing:hover {
            background-color: #c82333 !important; /* Darker Red for playing state on hover */
        }

        .nav-button:disabled, .toolbar-button:disabled {
            background-color: #adb5bd; /* Muted gray for disabled */
            color: #6c757d;
            cursor: not-allowed;
            box-shadow: none;
        }
        #frameIndicator, #zoomIndicator {
            margin: 0 8px;
            font-size: 14px;
            color: #495057;
            font-weight: 600;
            padding: 5px 8px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        
        .toolbar-divider { /* New class for dividers */
            height: 24px;
            width: 1px;
            background-color: #ced4da;
            margin: 0 12px;
        }
        .toolbar-flexible-spacer {
            flex-grow: 1;
        }


        /* Canvas styles */
        #drawingCanvas {
            border: 1px solid #ced4da; /* Softer border */
            background-color: #ffffff;
            box-shadow: 0 3px 6px rgba(0,0,0,0.07);
            border-radius: 8px;
            max-width: calc(100% - 40px); /* Ensure canvas does not overflow */
            display: block; /* Prevents extra space below canvas */
        }

        /* Instructions area styles */
        #instructions {
            margin-top: 25px;
            padding: 20px 25px;
            background-color: #ffffff; /* White background */
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            text-align: right;
            max-width: 800px;
            width: calc(100% - 70px); /* Ensure instructions do not overflow */
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            margin-bottom: 30px;
        }
        #instructions p strong { /* Main title of instructions */
            margin-top: 0;
            font-weight: 700;
            font-size: 1.2em;
            color: #007bff; /* Primary blue for title */
            display: block;
            margin-bottom: 15px;
        }
        #instructions ul {
            list-style-type: none; /* Remove default bullets */
            padding-right: 0;
        }
        #instructions li {
            margin-bottom: 10px;
            padding-right: 25px; /* Space for custom bullet */
            position: relative;
        }
        #instructions li::before { /* Custom bullet */
            content: "\f138"; /* Font Awesome circle arrow right or similar */
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            color: #007bff;
            position: absolute;
            right: 0;
            top: 1px;
        }
         #instructions ul ul {
            list-style-type: none;
            padding-right: 20px;
            margin-top: 8px;
        }
        #instructions ul ul li::before {
            content: "\f101"; /* Font Awesome angle right */
        }
        .button-text { /* Class for text next to icon */
            /* margin-left: 6px;  RTL: icon is to the right of text, or text is to the left of icon */
        }
        .icon-only .button-text {
            display: none; /* Hide text on larger screens for icon-only buttons if needed */
        }

        @media (max-width: 768px) { /* Example for mobile responsiveness */
            .toolbar-button .button-text, .file-input-label .button-text {
                /* display: none; /* Hide text, show only icon if desired on small screens */
            }
            .toolbar-button i, .file-input-label i {
                /* margin-right: 0; /* Adjust if text is hidden */
            }
            .toolbar-group {
                 margin-left: 5px;
            }
            #toolbar {
                padding: 10px;
                justify-content: space-around; /* Better spacing on small screens */
            }
            #frameIndicator, #zoomIndicator {
                font-size: 12px;
                padding: 4px 6px;
                margin: 0 4px;
            }
            .toolbar-divider {
                margin: 0 5px;
            }
        }
         @media (max-width: 480px) {
            .toolbar-button, .nav-button, .file-input-label {
                padding: 8px 10px;
                font-size: 13px;
            }
            .toolbar-button .button-text, .file-input-label .button-text {
                 display: none; /* Hide text on very small screens */
            }
             .toolbar-button i, .nav-button i, .file-input-label i {
                margin-right: 0;
            }
        }

    </style>
</head>
<body>
    <div id="toolbar">
        <div class="toolbar-group">
            <button id="editButton" class="toolbar-button" title="עריכה"><i class="fas fa-pencil-alt"></i><span class="button-text">עריכה</span></button>
        </div>

        <div class="toolbar-divider"></div>

        <div class="toolbar-group">
            <button id="undoButton" class="toolbar-button" title="בטל (Ctrl+Z)"><i class="fas fa-undo"></i></button>
            <button id="redoButton" class="toolbar-button" title="בצע שוב (Ctrl+Y)"><i class="fas fa-redo"></i></button>
        </div>

        <div class="toolbar-divider"></div>

        <div class="toolbar-group">
            <button id="prevFrameButton" class="nav-button" title="התמונה הקודמת"><i class="fas fa-chevron-right"></i></button>
            <span id="frameIndicator">תמונה: 1/1</span>
            <button id="nextFrameButton" class="nav-button" title="התמונה הבאה"><i class="fas fa-chevron-left"></i></button>
            <button id="addFrameButton" class="toolbar-button" title="הוסף תמונה"><i class="fas fa-plus-square"></i><span class="button-text">הוסף</span></button>
            <span id="zoomIndicator">זום: 100%</span>
        </div>
        
        <div class="toolbar-divider"></div>

        <div class="toolbar-group">
            <button id="saveMovieButton" class="toolbar-button" title="שמור סרט"><i class="fas fa-save"></i><span class="button-text">שמור</span></button>
            <label for="loadMovieInput" class="file-input-label toolbar-button" title="העלה סרט"><i class="fas fa-upload"></i><span class="button-text">העלה</span></label>
            <input type="file" id="loadMovieInput" accept=".clp" style="display: none;">
        </div>
        
        <div class="toolbar-divider"></div>
        
        <div class="toolbar-group">
             <button id="playMovieButton" class="toolbar-button" title="נגן/עצור סרט"><i class="fas fa-play"></i><span class="button-text">נגן</span></button>
        </div>

        <div class="toolbar-flexible-spacer"></div>
        
        <div class="toolbar-group">
            <button id="clearCanvasButton" class="toolbar-button" title="נקה הכל" style="background-color: #6c757d;"><i class="fas fa-trash-alt"></i><span class="button-text">נקה</span></button>
        </div>
    </div>

    <canvas id="drawingCanvas" width="800" height="500">
        הדפדפן שלך אינו תומך באלמנט ה-canvas.
    </canvas>

    <div dir="rtl" id="instructions">
        <p><strong><i class="fas fa-info-circle" style="margin-left: 8px;"></i>הוראות שימוש:</strong></p>
        <ul>
            <li>השתמש בכפתורי <strong>"בטל"</strong> (<i class="fas fa-undo"></i> Ctrl+Z) ו<strong>"בצע שוב"</strong> (<i class="fas fa-redo"></i> Ctrl+Y) לתיקונים.</li>
            <li>לחץ על <strong>"הוסף תמונה"</strong> (<i class="fas fa-plus-square"></i>) כדי ליצור תמונה חדשה באנימציה (תהיה עותק של הנוכחית).</li>
            <li>השתמש בחיצים (כעת הפוכים ויזואלית) כדי לנווט בין תמונות.</li>
            <li>**יצירת רצפים חדשים (נקודות עגינה וכו') אפשרית רק בתמונה הראשונה.**</li>
            <li>בכל תמונה, לחץ על משטח הציור כדי להתחיל לצייר רצף עקומות חדש (רק בתמונה 1) או להוסיף נקודות לרצף הנוכחי (רק בתמונה 1).</li>
            <li>בסיום ציור רצף בתמונה, לחץ על מקש <strong>רווח</strong>. הרצף יישמר בתמונה הנוכחית.</li>
            <li>השתמש ב<strong>גלגלת העכבר</strong> לזום. מציין הזום מופיע בסרגל הכלים.</li>
            <li>לחץ על כפתור <strong>"עריכה"</strong> (<i class="fas fa-pencil-alt"></i>):
                <ul>
                    <li>הרצפים בתמונה הנוכחית יהפכו לניתנים לעריכה. העקומות מהתמונה הקודמת יוצגו באפור.</li>
                    <li>מצב העריכה יישמר גם במעבר בין תמונות.</li>
                    <li>ניתן לגרור נקודות בקרה ועגינה. **ניתן גם לגרור רצף שלם על ידי לחיצה על הקו עצמו וגרירה.**</li>
                    <li>איחוד רצפים אפשרי רק בתמונה הראשונה.</li>
                </ul>
            </li>
            <li>לחץ על <strong>"נגן סרט"</strong> (<i class="fas fa-play"></i>) כדי לראות אנימציה של המעבר בין התמונות. לחיצה נוספת תעצור.</li>
            <li>לחץ על <strong>"שמור סרט"</strong> (<i class="fas fa-save"></i>) כדי לשמור את האנימציה לקובץ (`.clp`).</li>
            <li>לחץ על <strong>"העלה סרט"</strong> (<i class="fas fa-upload"></i>) כדי לטעון אנימציה מקובץ (`.clp`).</li>
            <li>לחץ על <strong>"נקה הכל"</strong> (<i class="fas fa-trash-alt"></i>) כדי לאפס את האפליקציה למצב התחלתי.</li>
            <li>לחיצה נוספת על "עריכה" תסיים את מצב העריכה.</li>
        </ul>
    </div>

    <script>
        // JavaScript code for the Bezier curve animation editor
        // Original source: https://orimosenzon.github.io/fun/vibe_coding/anim6.html
        // This script handles all the logic for drawing, editing, animating, saving, and loading Bezier curves.

        // DOM Element References
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const editButton = document.getElementById('editButton');
        const addFrameButton = document.getElementById('addFrameButton');
        const prevFrameButton = document.getElementById('prevFrameButton');
        const nextFrameButton = document.getElementById('nextFrameButton');
        const frameIndicator = document.getElementById('frameIndicator');
        const zoomIndicator = document.getElementById('zoomIndicator'); 
        const playMovieButton = document.getElementById('playMovieButton');
        const saveMovieButton = document.getElementById('saveMovieButton');
        const loadMovieInput = document.getElementById('loadMovieInput');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const clearCanvasButton = document.getElementById('clearCanvasButton'); 

        // --- Global State Variables ---
        let animationFrames = []; // Stores all frames of the animation. Each frame is an array of curve sequences.
        let currentFrameIndex = 0; // Index of the currently displayed/edited frame.
        
        // Represents the curve currently being drawn by the user before it's finalized.
        let activeCurve = { id: 'active_initial', anchors: [], segments: [], showAnchorsInEdit: true }; 

        let isDrawingMode = false;  // True if the user is currently adding points to a new curve.
        let isEditModeActive = false; // True if existing curves can be edited.
        
        let draggedPointInfo = null; // Information about the point/segment being dragged.
        let isDragging = false;      // True if a mouse drag operation is in progress.

        // --- Undo/Redo State ---
        let undoStack = []; // Stores previous states for undo functionality.
        let redoStack = []; // Stores undone states for redo functionality.
        const MAX_UNDO_STEPS = 50; // Maximum number of undo steps to store.

        // --- Zoom and Pan State ---
        let scaleFactor = 1.0; // Current zoom level of the canvas.
        let originX = 0; // X-coordinate of the canvas origin (for panning).
        let originY = 0; // Y-coordinate of the canvas origin (for panning).
        const ZOOM_INTENSITY = 0.1; // How much to zoom in/out on each wheel scroll.
        const MIN_SCALE = 0.001; // Minimum allowed zoom level.
        const MAX_SCALE = 1000.0; // Maximum allowed zoom level.

        // --- Animation State ---
        let isAnimating = false; // True if the animation is currently playing.
        let animationRequestID; // ID for canceling the animation frame request.
        let anim_sourceFrameIdx; // Index of the source frame for the current animation transition.
        let anim_targetFrameIdx; // Index of the target frame for the current animation transition.
        let anim_startTime; // Timestamp when the current transition started.
        const ANIM_DURATION_PER_TRANSITION = 1000; // Duration (ms) for each transition between frames.
        let anim_currentInterpolatedSequences = []; // Holds the curve data for the current interpolated animation step.

        // --- Drawing Constants ---
        const TENSION = 0.33; // Tension for calculating Catmull-Rom splines, influences Bezier control points.
        const VISUAL_ANCHOR_RADIUS_ON_SCREEN = 5; // Radius (pixels) for drawing anchor points on screen.
        const VISUAL_CONTROL_RADIUS_ON_SCREEN = 4; // Radius (pixels) for drawing control points on screen.
        const HIT_RADIUS_ON_SCREEN = 8; // Radius (pixels) for detecting mouse hits on points.
        const CURVE_HIT_THRESHOLD_ON_SCREEN = 5; // Threshold (pixels) for detecting mouse hits on curve lines.

        // --- Color Constants (Updated for new UI) ---
        const CURVE_COLOR = '#007bff'; // Main color for drawing curves.
        const ONION_SKIN_COLOR = 'rgba(108, 117, 125, 0.4)'; // Color for onion skinning (previous frame).
        const EDIT_ANCHOR_POINT_COLOR = '#343a40'; // Color for anchor points (position) in edit mode.
        const EDIT_CONTROL_POINT_COLOR = '#87CEEB'; // Light Blue (Sky Blue) color for control points (slope) in edit mode.
        const HELPER_LINE_COLOR = 'rgba(100, 100, 100, 0.3)'; // Color for lines connecting anchors to control points.
        const DRAW_MODE_FIRST_ANCHOR_COLOR = '#dc3545'; // Color for the first anchor point in drawing mode.
        const DRAW_MODE_OTHER_ANCHORS_COLOR = '#343a40'; // Color for subsequent anchor points in drawing mode.


        // --- Vector Math Helper Functions ---
        // These functions perform basic 2D vector operations.
        function vecAdd(v1, v2) { return { x: v1.x + v2.x, y: v1.y + v2.y }; }
        function vecSub(v1, v2) { return { x: v1.x - v2.x, y: v1.y - v2.y }; }
        function vecScale(v, s) { return { x: v.x * s, y: v.y * s }; }
        function vecLength(v) { return Math.sqrt(v.x * v.x + v.y * v.y); }
        function vecNormalize(v) {
            const len = vecLength(v);
            if (len === 0) return { x: 0, y: 0 }; // Avoid division by zero
            return vecScale(v, 1 / len);
        }

        // --- Bezier Calculation Logic ---
        /**
         * Calculates all Bezier curve segments for a given array of anchor points.
         * This implementation uses a method similar to Catmull-Rom to automatically
         * determine control points for smooth transitions between segments.
         * @param {Array<Object>} points - Array of anchor point objects {x, y}.
         * @param {number} tension - Tension factor influencing the curve's tightness.
         * @returns {Array<Object>} Array of segment objects, each with p0_obj, cp1, cp2, p1_obj.
         */
        function calculateAllBezierSegments(points, tension) {
            const segments = [];
            const numAnchors = points.length;
            if (numAnchors < 2) return []; // Not enough points to form a segment

            const anchor0_obj = points[0]; 
            const anchor1_obj = points[1]; 
            // First control point for the first segment
            let cp0_1 = vecAdd(anchor0_obj, vecScale(vecSub(anchor1_obj, anchor0_obj), tension));

            if (numAnchors === 2) { // Special case for a single segment (2 anchors)
                let cp0_2 = vecSub(anchor1_obj, vecScale(vecSub(anchor1_obj, anchor0_obj), tension));
                segments.push({ p0_obj: anchor0_obj, cp1: cp0_1, cp2: cp0_2, p1_obj: anchor1_obj });
                return segments;
            }

            const anchor2_obj = points[2];
            // Calculate tangent at the first interior anchor (points[1])
            let tangent_at_p1_dir = vecNormalize(vecSub(anchor2_obj, anchor0_obj));
            // Handle collinear points case
            if (tangent_at_p1_dir.x === 0 && tangent_at_p1_dir.y === 0) {
                tangent_at_p1_dir = vecNormalize(vecSub(anchor1_obj, anchor0_obj));
            }
            const len_p0p1 = vecLength(vecSub(anchor1_obj, anchor0_obj));
            // Second control point for the first segment
            let cp0_2 = vecSub(anchor1_obj, vecScale(tangent_at_p1_dir, len_p0p1 * tension));
            segments.push({ p0_obj: anchor0_obj, cp1: cp0_1, cp2: cp0_2, p1_obj: anchor1_obj });

            // Calculate segments for the rest of the points
            for (let i = 1; i < numAnchors - 1; i++) {
                const current_anchor_start_obj = points[i];
                const current_anchor_end_obj = points[i+1];
                
                // First control point of the current segment is mirrored from the previous segment's second control point
                const prev_segment_cp2 = segments[i-1].cp2;
                const current_cp1 = vecSub(vecScale(current_anchor_start_obj, 2), prev_segment_cp2);
                
                let current_cp2;
                if (i < numAnchors - 2) { // If there's a point after the current segment's end anchor
                    const anchor_next_next_obj = points[i+2];
                    let tangent_at_current_p_end_dir = vecNormalize(vecSub(anchor_next_next_obj, current_anchor_start_obj));
                     if (tangent_at_current_p_end_dir.x === 0 && tangent_at_current_p_end_dir.y === 0) { // Handle collinear points
                        tangent_at_current_p_end_dir = vecNormalize(vecSub(current_anchor_end_obj, current_anchor_start_obj));
                    }
                    const len_segment = vecLength(vecSub(current_anchor_end_obj, current_anchor_start_obj));
                    current_cp2 = vecSub(current_anchor_end_obj, vecScale(tangent_at_current_p_end_dir, len_segment * tension));
                } else { // Last segment
                    current_cp2 = vecSub(current_anchor_end_obj, vecScale(vecSub(current_anchor_end_obj, current_anchor_start_obj), tension));
                }
                segments.push({ p0_obj: current_anchor_start_obj, cp1: current_cp1, cp2: current_cp2, p1_obj: current_anchor_end_obj });
            }
            return segments;
        }
        
        // --- Undo/Redo and Cloning Logic ---
        /**
         * Creates a deep clone of a single curve sequence.
         * @param {Object} seq - The curve sequence to clone.
         * @returns {Object} A new, cloned curve sequence.
         */
        function cloneSingleSequence(seq) {
            if (!seq || !seq.anchors) return { id: 'empty_cloned_seq_' + Date.now(), anchors: [], segments: [], showAnchorsInEdit: false };
            
            // Clone anchors (simple objects)
            const newAnchors = seq.anchors.map(a => ({ ...a })); 
            
            // Clone segments, ensuring p0_obj and p1_obj reference the new anchor objects
            const newSegments = (seq.segments && Array.isArray(seq.segments)) ? seq.segments.map(seg => {
                // Find the index of original anchor objects to map to new anchor objects
                const p0Index = seq.anchors.indexOf(seg.p0_obj);
                const p1Index = seq.anchors.indexOf(seg.p1_obj);
                return {
                    cp1: { ...seg.cp1 }, 
                    cp2: { ...seg.cp2 },
                    // If original anchor was found, use the corresponding new anchor, otherwise keep null/original (should ideally always be found)
                    p0_obj: p0Index !== -1 ? newAnchors[p0Index] : null, 
                    p1_obj: p1Index !== -1 ? newAnchors[p1Index] : null
                };
            }) : [];
            
            return { 
                id: seq.id || 'cloned_seq_' + Date.now(), 
                anchors: newAnchors, 
                segments: newSegments, 
                showAnchorsInEdit: seq.showAnchorsInEdit 
            };
        }

        /**
         * Creates a deep clone of a single frame's data (an array of sequences).
         * @param {Array<Object>} sourceFrameData - The frame data to clone.
         * @returns {Array<Object>} A new, cloned frame data array.
         */
        function cloneSingleFrame(sourceFrameData) {
            if (!sourceFrameData || !Array.isArray(sourceFrameData)) return [];
            return sourceFrameData.map(seq => cloneSingleSequence(seq));
        }

        /**
         * Creates a deep clone of the entire animationFrames state.
         * @param {Array<Array<Object>>} sourceFrames - The animationFrames array to clone.
         * @returns {Array<Array<Object>>} A new, cloned animationFrames array.
         */
        function cloneAnimationFramesState(sourceFrames) {
            if (!sourceFrames || !Array.isArray(sourceFrames)) return [];
            return sourceFrames.map(frame => cloneSingleFrame(frame));
        }

        /**
         * Saves the current application state to the undo stack.
         * This includes animation frames, current frame index, active curve, modes, and view transform.
         */
        function saveStateForUndo() {
            if (isAnimating && draggedPointInfo === null) return; // Don't save state during animation playback, unless a drag operation is happening (like zoom)
            const state = {
                animationFrames: cloneAnimationFramesState(animationFrames), 
                currentFrameIndex: currentFrameIndex,
                activeCurve: cloneSingleSequence(activeCurve),
                isDrawingMode: isDrawingMode,
                isEditModeActive: isEditModeActive,
                scaleFactor: scaleFactor,
                originX: originX,
                originY: originY
            };
            undoStack.push(state);
            if (undoStack.length > MAX_UNDO_STEPS) {
                undoStack.shift(); // Remove oldest state if stack is full
            }
            redoStack = []; // Clear redo stack whenever a new action is performed
            updateUndoRedoButtons();
        }

        /**
         * Restores the application state from the undo stack.
         */
        function performUndo() {
            if (undoStack.length <= 1 || (isAnimating && draggedPointInfo === null) ) return; 
            
            saveStateToStack(redoStack, { 
                animationFrames: cloneAnimationFramesState(animationFrames), 
                currentFrameIndex: currentFrameIndex,
                activeCurve: cloneSingleSequence(activeCurve),
                isDrawingMode: isDrawingMode,
                isEditModeActive: isEditModeActive,
                scaleFactor: scaleFactor, originX: originX, originY: originY
            });
            
            const prevState = undoStack.pop(); 
            animationFrames = prevState.animationFrames; 
            currentFrameIndex = prevState.currentFrameIndex;
            activeCurve = prevState.activeCurve; 
            isDrawingMode = prevState.isDrawingMode;
            isEditModeActive = prevState.isEditModeActive; 
            scaleFactor = prevState.scaleFactor;
            originX = prevState.originX;
            originY = prevState.originY;

            if (animationFrames[currentFrameIndex]) {
                 animationFrames[currentFrameIndex].forEach(seq => seq.showAnchorsInEdit = isEditModeActive);
            }

            updateUndoRedoButtons();
            updateFrameUI();
            redrawCanvas();
        }

        /**
         * Restores the application state from the redo stack.
         */
        function performRedo() {
            if (redoStack.length === 0 || (isAnimating && draggedPointInfo === null) ) return;
            saveStateToStack(undoStack, { 
                animationFrames: cloneAnimationFramesState(animationFrames), 
                currentFrameIndex: currentFrameIndex,
                activeCurve: cloneSingleSequence(activeCurve),
                isDrawingMode: isDrawingMode,
                isEditModeActive: isEditModeActive,
                scaleFactor: scaleFactor, originX: originX, originY: originY
            });

            const nextState = redoStack.pop();
            animationFrames = nextState.animationFrames; 
            currentFrameIndex = nextState.currentFrameIndex;
            activeCurve = nextState.activeCurve;
            isDrawingMode = nextState.isDrawingMode;
            isEditModeActive = nextState.isEditModeActive; 
            scaleFactor = nextState.scaleFactor;
            originX = nextState.originX;
            originY = nextState.originY;

            if (animationFrames[currentFrameIndex]) {
                 animationFrames[currentFrameIndex].forEach(seq => seq.showAnchorsInEdit = isEditModeActive);
            }

            updateUndoRedoButtons();
            updateFrameUI();
            redrawCanvas();
        }
        
        /**
         * Helper function to push state onto a stack (undo or redo) and manage its size.
         * @param {Array} stack - The stack (undoStack or redoStack).
         * @param {Object} state - The state object to push.
         */
        function saveStateToStack(stack, state) {
            stack.push(state);
            if (stack.length > MAX_UNDO_STEPS) { 
                stack.shift(); 
            }
        }

        /**
         * Updates the enabled/disabled state of undo and redo buttons.
         */
        function updateUndoRedoButtons() {
            undoButton.disabled = undoStack.length <= 1 || (isAnimating && draggedPointInfo === null); 
            redoButton.disabled = redoStack.length === 0 || (isAnimating && draggedPointInfo === null);
        }


        // --- Frame Management ---
        /**
         * Resets the entire application to its initial, empty state.
         */
        function resetApplicationToInitialState() {
            animationFrames = [[]]; 
            currentFrameIndex = 0;
            activeCurve = { id: 'active_reset_' + Date.now(), anchors: [], segments: [], showAnchorsInEdit: true };
            isDrawingMode = false;
            isEditModeActive = false; 
            scaleFactor = 1.0;    
            originX = 0;          
            originY = 0;
            
            undoStack = []; 
            redoStack = [];
            saveStateForUndo(); 

            updateFrameUI();    
            redrawCanvas();     
        }

        /**
         * Initializes the application when the page loads.
         */
        function initializeAppOnLoad() {
            resetApplicationToInitialState();
        }
        
        /**
         * Updates the zoom level indicator in the UI.
         */
        function updateZoomIndicator() {
            zoomIndicator.textContent = `זום: ${Math.round(scaleFactor * 100)}%`;
        }

        /**
         * Updates all UI elements related to frame navigation, editing modes, and playback.
         */
        function updateFrameUI() {
            frameIndicator.textContent = `תמונה: ${currentFrameIndex + 1}/${animationFrames.length}`;
            updateZoomIndicator(); 
            prevFrameButton.disabled = (isAnimating && draggedPointInfo === null) || currentFrameIndex === 0;
            nextFrameButton.disabled = (isAnimating && draggedPointInfo === null) || currentFrameIndex === animationFrames.length - 1;
            addFrameButton.disabled = (isAnimating && draggedPointInfo === null);
            editButton.classList.toggle('active', isEditModeActive);
            
            const currentFrameSequences = animationFrames[currentFrameIndex];
            const currentFrameHasContent = currentFrameSequences && currentFrameSequences.length > 0;
            editButton.disabled = (isAnimating && draggedPointInfo === null) || (!currentFrameHasContent && currentFrameIndex !== 0 && !isDrawingMode); 
            
            playMovieButton.disabled = animationFrames.length < 2;
            playMovieButton.classList.toggle('playing', isAnimating);
            
            const playIcon = playMovieButton.querySelector('i');
            const playTextSpan = playMovieButton.querySelector('.button-text');

            if (isAnimating) {
                if (playIcon) playIcon.className = 'fas fa-stop';
                if (playTextSpan) playTextSpan.textContent = "עצור";
                playMovieButton.title = "עצור סרט";
            } else {
                if (playIcon) playIcon.className = 'fas fa-play';
                if (playTextSpan) playTextSpan.textContent = "נגן";
                playMovieButton.title = "נגן סרט";
            }

            saveMovieButton.disabled = (isAnimating && draggedPointInfo === null) || animationFrames.length === 0 || (animationFrames.length === 1 && (!animationFrames[0] || animationFrames[0].length === 0));
            loadMovieInput.disabled = (isAnimating && draggedPointInfo === null); 
            updateUndoRedoButtons();
        }
        
        /**
         * "Rehydrates" frame data loaded from a file.
         */
        function rehydrateFrameData(loadedFrames) { 
            return loadedFrames.map(frame => 
                frame.map(seq => {
                    const rehydratedAnchors = seq.anchors.map(a => ({...a})); 
                    const rehydratedSegments = seq.segments.map(seg => {
                        let p0_ref = null;
                        let p1_ref = null;
                        if (seg.p0_obj && typeof seg.p0_obj.x !== 'undefined') { 
                           p0_ref = rehydratedAnchors.find(a => a.x === seg.p0_obj.x && a.y === seg.p0_obj.y);
                        }
                        if (seg.p1_obj && typeof seg.p1_obj.x !== 'undefined') { 
                           p1_ref = rehydratedAnchors.find(a => a.x === seg.p1_obj.x && a.y === seg.p1_obj.y);
                        }
                        return {
                            ...seg, 
                            p0_obj: p0_ref || seg.p0_obj, 
                            p1_obj: p1_ref || seg.p1_obj  
                        };
                    });
                    return { ...seq, anchors: rehydratedAnchors, segments: rehydratedSegments };
                })
            );
        }

        // --- Canvas Drawing Functions ---
        /**
         * Draws a set of curve sequences on the canvas.
         */
        function drawCurveSequence(sequences, color, lineWidth, drawEditPoints = false) {
            sequences.forEach(seq => {
                if (seq.segments && seq.segments.length > 0) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = lineWidth / scaleFactor; 
                    ctx.beginPath();
                    seq.segments.forEach(segData => {
                        if (!segData.p0_obj || !segData.p1_obj) {
                            console.warn("Segment missing p0_obj or p1_obj during drawing", segData, seq);
                            return; 
                        }
                        ctx.moveTo(segData.p0_obj.x, segData.p0_obj.y);
                        ctx.bezierCurveTo(segData.cp1.x, segData.cp1.y, segData.cp2.x, segData.cp2.y, segData.p1_obj.x, segData.p1_obj.y);
                    });
                    ctx.stroke();
                }

                if (drawEditPoints && isEditModeActive && seq.showAnchorsInEdit) {
                    const anchorDrawRadiusInWorld = VISUAL_ANCHOR_RADIUS_ON_SCREEN / scaleFactor;
                    const controlDrawRadiusInWorld = VISUAL_CONTROL_RADIUS_ON_SCREEN / scaleFactor;
                    
                    seq.anchors.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, anchorDrawRadiusInWorld, 0, 2 * Math.PI);
                        ctx.fillStyle = EDIT_ANCHOR_POINT_COLOR; 
                        ctx.fill();
                    });

                    if (seq.segments) {
                        ctx.save(); 
                        ctx.strokeStyle = HELPER_LINE_COLOR; 
                        ctx.lineWidth = 1 / scaleFactor; 
                        seq.segments.forEach(segData => {
                             if (!segData.p0_obj || !segData.p1_obj) return; 
                            
                            ctx.beginPath(); ctx.moveTo(segData.p0_obj.x, segData.p0_obj.y); ctx.lineTo(segData.cp1.x, segData.cp1.y); ctx.stroke();
                            ctx.beginPath(); ctx.arc(segData.cp1.x, segData.cp1.y, controlDrawRadiusInWorld, 0, 2 * Math.PI); 
                            ctx.fillStyle = EDIT_CONTROL_POINT_COLOR; 
                            ctx.fill();

                            ctx.beginPath(); ctx.moveTo(segData.p1_obj.x, segData.p1_obj.y); ctx.lineTo(segData.cp2.x, segData.cp2.y); ctx.stroke();
                            ctx.beginPath(); ctx.arc(segData.cp2.x, segData.cp2.y, controlDrawRadiusInWorld, 0, 2 * Math.PI); 
                            ctx.fillStyle = EDIT_CONTROL_POINT_COLOR; 
                            ctx.fill();
                        });
                        ctx.restore(); 
                    }
                }
            });
        }

        /**
         * Clears and redraws the entire canvas based on the current state.
         */
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            ctx.save(); 
            ctx.translate(originX, originY); 
            ctx.scale(scaleFactor, scaleFactor); 

            if (isAnimating) {
                drawCurveSequence(anim_currentInterpolatedSequences, CURVE_COLOR, 2.5, false);
            } else {
                if (currentFrameIndex > 0 && animationFrames[currentFrameIndex - 1]) {
                    drawCurveSequence(animationFrames[currentFrameIndex - 1], ONION_SKIN_COLOR, 2.5, false);
                }
                if (animationFrames[currentFrameIndex]) {
                    drawCurveSequence(animationFrames[currentFrameIndex], CURVE_COLOR, 2.5, true); 
                }
                if (isDrawingMode && activeCurve.segments && activeCurve.segments.length > 0) {
                    ctx.strokeStyle = CURVE_COLOR;
                    ctx.lineWidth = 2.5 / scaleFactor;
                    ctx.beginPath();
                    activeCurve.segments.forEach(seg => {
                        if (!seg.p0_obj || !seg.p1_obj) return;
                        ctx.moveTo(seg.p0_obj.x, seg.p0_obj.y);
                        ctx.bezierCurveTo(seg.cp1.x, seg.cp1.y, seg.cp2.x, seg.cp2.y, seg.p1_obj.x, seg.p1_obj.y);
                    });
                    ctx.stroke();
                }
                if (isDrawingMode && activeCurve.anchors) {
                    const anchorDrawRadiusInWorld = VISUAL_ANCHOR_RADIUS_ON_SCREEN / scaleFactor;
                    activeCurve.anchors.forEach((point, index) => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, anchorDrawRadiusInWorld, 0, 2 * Math.PI);
                        ctx.fillStyle = (index === 0) ? DRAW_MODE_FIRST_ANCHOR_COLOR : DRAW_MODE_OTHER_ANCHORS_COLOR; 
                        ctx.fill();
                    });
                }
            }
            ctx.restore(); 
        }
        
        // --- Mouse Position Utility ---
        /**
         * Gets mouse coordinates relative to the canvas element.
         */
        function getMouseCanvasPos(event) {
            const rect = canvas.getBoundingClientRect(); 
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY
            };
        }

        /**
         * Gets mouse coordinates in the "world" space (considering pan and zoom).
         */
        function getMouseWorldPos(event) {
            const mouseCanvasPos = getMouseCanvasPos(event);
            return {
                x: (mouseCanvasPos.x - originX) / scaleFactor,
                y: (mouseCanvasPos.y - originY) / scaleFactor
            };
        }

        // --- Curve Hit Detection ---
        /**
         * Calculates a point on a Bezier curve at a given parameter t.
         */
        function getPointOnBezier(p0, cp1, cp2, p1, t) {
            const mt = 1 - t; 
            const mt2 = mt * mt;
            const mt3 = mt2 * mt;
            const t2 = t * t;
            const t3 = t2 * t;

            const x = mt3 * p0.x + 3 * mt2 * t * cp1.x + 3 * mt * t2 * cp2.x + t3 * p1.x;
            const y = mt3 * p0.y + 3 * mt2 * t * cp1.y + 3 * mt * t2 * cp2.y + t3 * p1.y;
            return { x, y };
        }

        /**
         * Checks if a given mouse position is near a Bezier curve segment.
         */
        function isPointNearBezier(mousePos, p0_obj, cp1, cp2, p1_obj, hitThresholdInWorld) {
            const steps = 20; 
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const pointOnCurve = getPointOnBezier(p0_obj, cp1, cp2, p1_obj, t);
                if (vecLength(vecSub(mousePos, pointOnCurve)) < hitThresholdInWorld) {
                    return true; 
                }
            }
            return false; 
        }


        // --- Merge Sequences Logic ---
        /**
         * Merges two curve sequences (seqA and seqB) if an endpoint of seqA is dragged
         * onto an endpoint of seqB. This is only allowed in the first frame.
         */
        function mergeAndReplaceSequences(currentFrameCurves, seqA, draggedAnchorIndexOnA, seqB, targetAnchorIndexOnB) {
            if (currentFrameIndex !== 0) { 
                console.warn("Merging sequences is only allowed in the first frame.");
                return false;
            }
            saveStateForUndo(); 
            let finalAnchors = [];
            const anchorsA = [...seqA.anchors]; 
            const anchorsB = [...seqB.anchors];
            const isDraggedAStart = (draggedAnchorIndexOnA === 0);
            const isTargetBStart = (targetAnchorIndexOnB === 0);

            if (!isDraggedAStart && isTargetBStart) { 
                finalAnchors = [...anchorsA, ...anchorsB.slice(1)]; 
            } else if (isDraggedAStart && !isTargetBStart) { 
                finalAnchors = [...anchorsB.reverse(), ...anchorsA.slice(1)]; 
            } else if (isDraggedAStart && isTargetBStart) { 
                finalAnchors = [...anchorsA.reverse(), ...anchorsB.slice(1)]; 
            } else if (!isDraggedAStart && !isTargetBStart) { 
                finalAnchors = [...anchorsA, ...anchorsB.reverse().slice(1)]; 
            } else { return false; } 

            if (finalAnchors.length < 2) { return false; } 

            const indexA = currentFrameCurves.findIndex(s => s.id === seqA.id);
            if (indexA > -1) currentFrameCurves.splice(indexA, 1);
            const indexB = currentFrameCurves.findIndex(s => s.id === seqB.id);
            if (indexB > -1) currentFrameCurves.splice(indexB, 1);

            const newMergedId = 'merged_' + Date.now() + Math.random(); 
            const newSegments = calculateAllBezierSegments(finalAnchors, TENSION); 
            currentFrameCurves.push({
                id: newMergedId,
                anchors: finalAnchors, 
                segments: newSegments, 
                showAnchorsInEdit: true 
            });

            for (let i = 1; i < animationFrames.length; i++) {
                animationFrames[i] = cloneSingleFrame(animationFrames[0]); 
                animationFrames[i].forEach(s => s.showAnchorsInEdit = false); 
            }
            return true; 
        }

        // --- Animation Logic ---
        /**
         * Interpolates a single point between two points p1 and p2 based on parameter t.
         */
        function interpolatePoint(p1, p2, t) {
            return {
                x: p1.x + (p2.x - p1.x) * t,
                y: p1.y + (p2.y - p1.y) * t
            };
        }

        /**
         * Interpolates all sequences between two frames (seqsA and seqsB) at parameter t.
         */
        function interpolateSequences(seqsA, seqsB, t) {
            if (!seqsA || !seqsB || seqsA.length !== seqsB.length) {
                console.warn("Cannot interpolate: Mismatched sequence structures or undefined frames. Displaying source frame.", seqsA, seqsB);
                return seqsA ? cloneSingleFrame(seqsA) : []; 
            }

            return seqsA.map((seqA, seqIdx) => {
                const seqB = seqsB[seqIdx];
                if (!seqB || seqA.anchors.length !== seqB.anchors.length || seqA.segments.length !== seqB.segments.length) {
                     console.warn(`Mismatched structure in sequence ID ${seqA.id}. Displaying source sequence.`, seqA, seqB);
                     return cloneSingleSequence(seqA); 
                }

                const interpolatedAnchors = seqA.anchors.map((anchorA, anchorIdx) => {
                    return interpolatePoint(anchorA, seqB.anchors[anchorIdx], t);
                });
                
                const interpolatedSegments = seqA.segments.map((segA, seg_idx) => {
                    const segB = seqB.segments[seg_idx];
                    
                    const p0_original_in_A = segA.p0_obj;
                    const p1_original_in_A = segA.p1_obj;
                    const p0_original_idx_in_A_anchors = seqA.anchors.findIndex(a => a === p0_original_in_A);
                    const p1_original_idx_in_A_anchors = seqA.anchors.findIndex(a => a === p1_original_in_A);

                    return {
                        p0_obj: interpolatedAnchors[p0_original_idx_in_A_anchors],
                        cp1: interpolatePoint(segA.cp1, segB.cp1, t),
                        cp2: interpolatePoint(segA.cp2, segB.cp2, t),
                        p1_obj: interpolatedAnchors[p1_original_idx_in_A_anchors]
                    };
                });
                return {
                    id: seqA.id, 
                    anchors: interpolatedAnchors,
                    segments: interpolatedSegments,
                    showAnchorsInEdit: false 
                };
            });
        }

        /**
         * The main animation loop, called via requestAnimationFrame.
         */
        function animationLoop(timestamp) {
            if (!isAnimating) return; 

            if (!anim_startTime) anim_startTime = timestamp; 
            const elapsedTime = timestamp - anim_startTime;
            let t = elapsedTime / ANIM_DURATION_PER_TRANSITION; 

            if (t >= 1) { 
                t = 1; 
                anim_currentInterpolatedSequences = cloneSingleFrame(animationFrames[anim_targetFrameIdx]); 
                redrawCanvas(); 

                anim_sourceFrameIdx++;
                anim_targetFrameIdx++;
                anim_startTime = timestamp; 

                if (anim_targetFrameIdx >= animationFrames.length) {
                    anim_sourceFrameIdx = 0;
                    anim_targetFrameIdx = 1;
                    if (animationFrames.length < 2) { 
                        stopAnimation();
                        return;
                    }
                }
                if (!animationFrames[anim_sourceFrameIdx] || !animationFrames[anim_targetFrameIdx]) {
                    console.error("Animation frames missing during loop.");
                    stopAnimation();
                    return;
                }
                t = 0; 
            }
            
            const sourceFrameData = animationFrames[anim_sourceFrameIdx];
            const targetFrameData = animationFrames[anim_targetFrameIdx];
            anim_currentInterpolatedSequences = interpolateSequences(sourceFrameData, targetFrameData, t);
            
            redrawCanvas();
            animationRequestID = requestAnimationFrame(animationLoop); 
        }

        /**
         * Starts the animation playback.
         */
        function startAnimation() {
            if (animationFrames.length < 2) return; 
            saveStateForUndo(); 
            
            if (isDrawingMode && activeCurve.anchors.length > 0) { 
                 const currentFrameSequences = animationFrames[currentFrameIndex];
                 currentFrameSequences.push({
                    id: 'finalized_before_anim_' + Date.now(),
                    anchors: [...activeCurve.anchors],
                    segments: [...activeCurve.segments],
                    showAnchorsInEdit: false 
                });
                activeCurve = { id: 'active_cleared_for_anim', anchors: [], segments: [], showAnchorsInEdit: true };
                isDrawingMode = false;
            }

            isAnimating = true;
            isEditModeActive = false; 
            
            anim_sourceFrameIdx = 0;
            anim_targetFrameIdx = 1;
            anim_startTime = null; 
            anim_currentInterpolatedSequences = cloneSingleFrame(animationFrames[0]); 

            updateFrameUI();
            animationRequestID = requestAnimationFrame(animationLoop);
        }

        /**
         * Stops the animation playback.
         */
        function stopAnimation() {
            isAnimating = false;
            cancelAnimationFrame(animationRequestID);
            currentFrameIndex = anim_sourceFrameIdx !== undefined ? anim_sourceFrameIdx : currentFrameIndex; 
            anim_currentInterpolatedSequences = []; 
            updateFrameUI();
            redrawCanvas(); 
        }

        playMovieButton.addEventListener('click', () => {
            if (isAnimating) {
                stopAnimation();
            } else {
                startAnimation();
            }
        });


        // --- Event Handlers (mousedown, mousemove, mouseup, keydown, wheel) ---
        /**
         * Handles common tasks after frame navigation.
         */
        function handleFrameNavigation() {
            saveStateForUndo(); 
            const currentFrameSequences = animationFrames[currentFrameIndex];
            if (currentFrameSequences) {
                 currentFrameSequences.forEach(seq => seq.showAnchorsInEdit = isEditModeActive);
            }
            updateFrameUI();
            redrawCanvas();
        }

        addFrameButton.addEventListener('click', () => {
            if (isAnimating && draggedPointInfo === null) return;
            saveStateForUndo(); 
            
            if (isDrawingMode && activeCurve.anchors.length > 0) { 
                 const currentFrameSequences = animationFrames[currentFrameIndex];
                 currentFrameSequences.push({
                    id: 'finalized_on_add_frame_' + Date.now(),
                    anchors: [...activeCurve.anchors],
                    segments: [...activeCurve.segments],
                    showAnchorsInEdit: false 
                });
                activeCurve = { id: 'active_cleared_on_add_frame', anchors: [], segments: [], showAnchorsInEdit: true };
                isDrawingMode = false;
            }

            const currentFrameData = animationFrames[currentFrameIndex] || [];
            const newFrameData = cloneSingleFrame(currentFrameData); 
            newFrameData.forEach(seq => seq.showAnchorsInEdit = isEditModeActive); 

            const newFrameTargetIndex = currentFrameIndex + 1; 
            animationFrames.splice(newFrameTargetIndex, 0, newFrameData);
            currentFrameIndex = newFrameTargetIndex; 
            
            updateFrameUI(); 
            redrawCanvas(); 
        });

        prevFrameButton.addEventListener('click', () => {
            if (currentFrameIndex > 0 && !(isAnimating && draggedPointInfo === null)) {
                if (isDrawingMode && activeCurve.anchors.length > 0) {
                    const frameWeAreLeaving = animationFrames[currentFrameIndex];
                    if (frameWeAreLeaving) { 
                        frameWeAreLeaving.push(cloneSingleSequence(activeCurve));
                    }
                    activeCurve = { id: 'active_nav_prev_clear', anchors: [], segments: [], showAnchorsInEdit: true };
                    isDrawingMode = false;
                }
                currentFrameIndex--;
                handleFrameNavigation(); 
            }
        });

        nextFrameButton.addEventListener('click', () => {
            if (currentFrameIndex < animationFrames.length - 1 && !(isAnimating && draggedPointInfo === null)) {
                if (isDrawingMode && activeCurve.anchors.length > 0) {
                    const frameWeAreLeaving = animationFrames[currentFrameIndex];
                    if (frameWeAreLeaving) {
                        frameWeAreLeaving.push(cloneSingleSequence(activeCurve));
                    }
                    activeCurve = { id: 'active_nav_next_clear', anchors: [], segments: [], showAnchorsInEdit: true };
                    isDrawingMode = false;
                }
                currentFrameIndex++;
                handleFrameNavigation(); 
            }
        });

        editButton.addEventListener('click', () => {
            if (isAnimating && draggedPointInfo === null) return; 
            saveStateForUndo(); 
            isEditModeActive = !isEditModeActive; 

            const currentFrameSequences = animationFrames[currentFrameIndex];
            if (isEditModeActive) {
                if (isDrawingMode && activeCurve.anchors.length > 1 && currentFrameIndex === 0) { 
                    currentFrameSequences.push(cloneSingleSequence(activeCurve));
                    activeCurve = { id: 'active_edit_toggle_finalize', anchors: [], segments: [], showAnchorsInEdit: true }; 
                }
                isDrawingMode = false; 
                if (currentFrameSequences) {
                    currentFrameSequences.forEach(seq => seq.showAnchorsInEdit = true);
                }
            } else { 
                if (currentFrameSequences) {
                    currentFrameSequences.forEach(seq => seq.showAnchorsInEdit = false);
                }
                isDragging = false; 
                draggedPointInfo = null;
            }
            updateFrameUI();
            redrawCanvas();
        });

        canvas.addEventListener('mousedown', (event) => {
            if (isAnimating && draggedPointInfo === null) return; // Allow mousedown for zoom/pan during animation
            
            const mouseWorldPos = getMouseWorldPos(event); 
            const effectivePointHitRadius = HIT_RADIUS_ON_SCREEN / scaleFactor;
            const effectiveCurveHitRadius = CURVE_HIT_THRESHOLD_ON_SCREEN / scaleFactor;
            const currentFrameSequences = animationFrames[currentFrameIndex];

            if (isEditModeActive && currentFrameSequences) {
                let pointHit = false;
                for (let seqIndex = currentFrameSequences.length - 1; seqIndex >= 0; seqIndex--) { 
                    const seq = currentFrameSequences[seqIndex];
                    if (!seq.showAnchorsInEdit) continue; 

                    for (let i = 0; i < seq.anchors.length; i++) {
                        if (vecLength(vecSub(mouseWorldPos, seq.anchors[i])) < effectivePointHitRadius) {
                            saveStateForUndo(); 
                            isDragging = true;
                            draggedPointInfo = { 
                                type: 'anchor', seqId: seq.id, anchorIndex: i, pointObject: seq.anchors[i], 
                                cp2_incoming_offset: null, cp1_outgoing_offset: null
                            };
                            if (i > 0 && seq.segments && seq.segments[i-1]) { 
                                draggedPointInfo.cp2_incoming_offset = vecSub(seq.segments[i-1].cp2, seq.anchors[i]);
                            }
                            if (i < seq.anchors.length - 1 && seq.segments && seq.segments[i]) { 
                                draggedPointInfo.cp1_outgoing_offset = vecSub(seq.segments[i].cp1, seq.anchors[i]);
                            }
                            canvas.style.cursor = 'grabbing'; pointHit = true; break;
                        }
                    }
                    if (pointHit) break;

                    if (seq.segments) {
                        for (let i = 0; i < seq.segments.length; i++) {
                            const seg = seq.segments[i];
                            if (vecLength(vecSub(mouseWorldPos, seg.cp1)) < effectivePointHitRadius) {
                                saveStateForUndo(); 
                                isDragging = true;
                                draggedPointInfo = { 
                                    type: 'control', seqId: seq.id, segmentIndex: i, pointType: 'cp1', pointObject: seg.cp1 
                                };
                                canvas.style.cursor = 'grabbing'; pointHit = true; break;
                            }
                            if (vecLength(vecSub(mouseWorldPos, seg.cp2)) < effectivePointHitRadius) {
                                saveStateForUndo(); 
                                isDragging = true;
                                draggedPointInfo = { 
                                    type: 'control', seqId: seq.id, segmentIndex: i, pointType: 'cp2', pointObject: seg.cp2 
                                };
                                canvas.style.cursor = 'grabbing'; pointHit = true; break;
                            }
                        }
                    }
                    if (pointHit) break;
                }
                if (pointHit) return; 

                for (let seqIndex = currentFrameSequences.length - 1; seqIndex >= 0; seqIndex--) {
                    const seq = currentFrameSequences[seqIndex];
                    if (!seq.showAnchorsInEdit || !seq.segments) continue;
                    for (const seg of seq.segments) {
                        if (!seg.p0_obj || !seg.p1_obj) continue; 
                        if (isPointNearBezier(mouseWorldPos, seg.p0_obj, seg.cp1, seg.cp2, seg.p1_obj, effectiveCurveHitRadius)) {
                            saveStateForUndo(); 
                            isDragging = true;
                            draggedPointInfo = {
                                type: 'sequence',
                                seqId: seq.id,
                                initialMousePos: { ...mouseWorldPos } 
                            };
                            canvas.style.cursor = 'move';
                            return; 
                        }
                    }
                }
            } else if (!isEditModeActive) { // Only allow drawing if not in edit mode
                if (currentFrameIndex !== 0) { 
                    isDrawingMode = false; 
                    activeCurve = { id: 'active_attempt_draw_non_frame0', anchors: [], segments: [], showAnchorsInEdit: true };
                    console.warn("New curves can only be added in the first frame.");
                    return;
                }
                saveStateForUndo(); 
                if (!isDrawingMode) { 
                    isDrawingMode = true;
                    activeCurve = { id: 'active_drawing_' + Date.now(), anchors: [], segments: [], showAnchorsInEdit: true }; 
                }
                activeCurve.anchors.push({ x: mouseWorldPos.x, y: mouseWorldPos.y }); 
                if (activeCurve.anchors.length >= 2) {
                    activeCurve.segments = calculateAllBezierSegments(activeCurve.anchors, TENSION);
                }
                redrawCanvas();
            }
        });

        canvas.addEventListener('mousemove', (event) => {
            if (isAnimating && draggedPointInfo === null && !isEditModeActive) return; // Allow mousemove for cursor changes in edit mode during animation if needed, or for zoom
            const mouseWorldPos = getMouseWorldPos(event); 
            const effectivePointHitRadius = HIT_RADIUS_ON_SCREEN / scaleFactor;
            const effectiveCurveHitRadius = CURVE_HIT_THRESHOLD_ON_SCREEN / scaleFactor;
            const currentFrameSequences = animationFrames[currentFrameIndex];

            if (isDragging && draggedPointInfo && currentFrameSequences) {
                const targetSequence = currentFrameSequences.find(s => s.id === draggedPointInfo.seqId);
                if (!targetSequence) { 
                    isDragging = false; draggedPointInfo = null; return;
                }
                
                if (draggedPointInfo.type === 'anchor') {
                    draggedPointInfo.pointObject.x = mouseWorldPos.x;
                    draggedPointInfo.pointObject.y = mouseWorldPos.y;
                    const anchorIdx = draggedPointInfo.anchorIndex;
                    if (draggedPointInfo.cp2_incoming_offset && anchorIdx > 0 && targetSequence.segments && targetSequence.segments[anchorIdx - 1]) { 
                        const new_cp2_pos = vecAdd(draggedPointInfo.pointObject, draggedPointInfo.cp2_incoming_offset);
                        targetSequence.segments[anchorIdx - 1].cp2.x = new_cp2_pos.x;
                        targetSequence.segments[anchorIdx - 1].cp2.y = new_cp2_pos.y;
                    }
                    if (draggedPointInfo.cp1_outgoing_offset && anchorIdx < targetSequence.anchors.length - 1 && targetSequence.segments && targetSequence.segments[anchorIdx]) { 
                        const new_cp1_pos = vecAdd(draggedPointInfo.pointObject, draggedPointInfo.cp1_outgoing_offset);
                        targetSequence.segments[anchorIdx].cp1.x = new_cp1_pos.x;
                        targetSequence.segments[anchorIdx].cp1.y = new_cp1_pos.y;
                    }
                } else if (draggedPointInfo.type === 'control') {
                    draggedPointInfo.pointObject.x = mouseWorldPos.x;
                    draggedPointInfo.pointObject.y = mouseWorldPos.y;
                    const segIdx = draggedPointInfo.segmentIndex;
                    const pointType = draggedPointInfo.pointType;
                    if (pointType === 'cp1') { 
                        if (segIdx > 0 && targetSequence.anchors[segIdx]) {
                            const pivot = targetSequence.anchors[segIdx]; 
                            const draggedCp = targetSequence.segments[segIdx].cp1; 
                            targetSequence.segments[segIdx-1].cp2 = vecSub(vecScale(pivot, 2), draggedCp);
                        }
                    } else if (pointType === 'cp2') { 
                        if (segIdx < targetSequence.segments.length - 1 && targetSequence.anchors[segIdx+1]) {
                            const pivot = targetSequence.anchors[segIdx+1]; 
                            const draggedCp = targetSequence.segments[segIdx].cp2; 
                            targetSequence.segments[segIdx+1].cp1 = vecSub(vecScale(pivot, 2), draggedCp);
                        }
                    }
                } else if (draggedPointInfo.type === 'sequence') {
                    const delta = vecSub(mouseWorldPos, draggedPointInfo.initialMousePos);
                    targetSequence.anchors.forEach(anchor => {
                        anchor.x += delta.x;
                        anchor.y += delta.y;
                    });
                    targetSequence.segments.forEach(seg => {
                        seg.cp1.x += delta.x;
                        seg.cp1.y += delta.y;
                        seg.cp2.x += delta.x;
                        seg.cp2.y += delta.y;
                    });
                    draggedPointInfo.initialMousePos = { ...mouseWorldPos }; 
                }
                redrawCanvas();

            } else if (isEditModeActive && currentFrameSequences) { 
                let newCursor = 'default'; 
                
                for (const seq of currentFrameSequences) {
                    if (!seq.showAnchorsInEdit) continue;
                    let pointHover = false;
                    for (const anchor of seq.anchors) {
                        if (vecLength(vecSub(mouseWorldPos, anchor)) < effectivePointHitRadius) { newCursor = 'grab'; pointHover = true; break; }
                    }
                    if (pointHover) break;
                    if (seq.segments) {
                        for (const seg of seq.segments) {
                            if (vecLength(vecSub(mouseWorldPos, seg.cp1)) < effectivePointHitRadius || 
                                vecLength(vecSub(mouseWorldPos, seg.cp2)) < effectivePointHitRadius) {
                                newCursor = 'grab'; pointHover = true; break;
                            }
                        }
                    }
                    if (pointHover) break;
                    if (seq.segments) {
                        for (const seg of seq.segments) {
                            if (!seg.p0_obj || !seg.p1_obj) continue;
                            if (isPointNearBezier(mouseWorldPos, seg.p0_obj, seg.cp1, seg.cp2, seg.p1_obj, effectiveCurveHitRadius)) {
                                newCursor = 'move'; break;
                            }
                        }
                    }
                    if (newCursor === 'move' || newCursor === 'grab') break; 
                }
                canvas.style.cursor = newCursor;
            } else if (!isEditModeActive) { 
                 canvas.style.cursor = 'crosshair';
            }
        });

        canvas.addEventListener('mouseup', () => {
            // Allow mouseup to stop dragging even during animation (for zoom/pan)
            // if (isAnimating && draggedPointInfo === null) return; // Original check, might be too restrictive
            
            const currentFrameSequences = animationFrames[currentFrameIndex];
            if (isDragging && draggedPointInfo && draggedPointInfo.type === 'anchor' && currentFrameSequences) {
                const draggedSeq = currentFrameSequences.find(s => s.id === draggedPointInfo.seqId);
                const draggedAnchorIndex = draggedPointInfo.anchorIndex;

                if (draggedSeq && 
                    (draggedAnchorIndex === 0 || draggedAnchorIndex === draggedSeq.anchors.length - 1) && 
                    currentFrameIndex === 0) { 
                    
                    const draggedAnchorPos = draggedSeq.anchors[draggedAnchorIndex];
                    const effectiveWorldHitRadius = HIT_RADIUS_ON_SCREEN / scaleFactor; 
                    let mergedSuccessfully = false;

                    for (let i = 0; i < currentFrameSequences.length; i++) {
                        const otherSeq = currentFrameSequences[i];
                        if (otherSeq.id === draggedSeq.id) continue; 

                        if (otherSeq.anchors.length > 0) { 
                            const otherStartPoint = otherSeq.anchors[0];
                            if (vecLength(vecSub(draggedAnchorPos, otherStartPoint)) < effectiveWorldHitRadius) {
                                if (mergeAndReplaceSequences(currentFrameCurves, draggedSeq, draggedAnchorIndex, otherSeq, 0)) {
                                    mergedSuccessfully = true;
                                }
                                break; 
                            }
                            if (otherSeq.anchors.length > 1 || (otherSeq.anchors.length === 1 && otherSeq.anchors[0] !== otherStartPoint) ) { 
                                const otherEndPoint = otherSeq.anchors[otherSeq.anchors.length - 1];
                                if (vecLength(vecSub(draggedAnchorPos, otherEndPoint)) < effectiveWorldHitRadius) {
                                    if (mergeAndReplaceSequences(currentFrameCurves, draggedSeq, draggedAnchorIndex, otherSeq, otherSeq.anchors.length - 1)) {
                                        mergedSuccessfully = true;
                                    }
                                    break; 
                                }
                            }
                        }
                    }
                    if (mergedSuccessfully) {
                        isDragging = false; draggedPointInfo = null;
                        canvas.style.cursor = isEditModeActive ? 'grab' : 'crosshair'; 
                        redrawCanvas();
                        return; 
                    }
                }
            }

            isDragging = false; 
            draggedPointInfo = null;
            if (canvas.style.cursor === 'grabbing') {
                 canvas.style.cursor = isEditModeActive ? 'grab' : 'crosshair';
            } else if (!isEditModeActive && !isAnimating) { // Only reset to crosshair if not animating and not edit mode
                 canvas.style.cursor = 'crosshair';
            } 
            redrawCanvas(); 
        });

        canvas.addEventListener('mouseleave', () => {
            if (isDragging) { 
                isDragging = false; 
                draggedPointInfo = null;
                redrawCanvas(); 
            }
            if (!isAnimating) { // Don't change cursor if animating and mouse leaves
                canvas.style.cursor = 'default'; 
            }
        });

        window.addEventListener('keydown', (event) => {
            if (isAnimating && draggedPointInfo === null) return; 

            if (event.ctrlKey && event.key === 'z') {
                event.preventDefault(); 
                performUndo();
            } 
            else if (event.ctrlKey && (event.key === 'y' || (event.key === 'Z' && event.shiftKey))) { 
                event.preventDefault(); 
                performRedo();
            } 
            else if (event.code === 'Space' && !isEditModeActive) {
                event.preventDefault(); 
                if (isDrawingMode && activeCurve.anchors.length > 1) { 
                   saveStateForUndo(); 
                   const currentFrameSequences = animationFrames[currentFrameIndex];
                   currentFrameSequences.push({ 
                       id: 'finalized_by_space_' + Date.now(),
                       anchors: [...activeCurve.anchors], 
                       segments: [...activeCurve.segments], 
                       showAnchorsInEdit: false 
                   });
                   if (currentFrameIndex === 0) {
                       for (let i = 1; i < animationFrames.length; i++) {
                            animationFrames[i] = cloneSingleFrame(animationFrames[0]); 
                            animationFrames[i].forEach(s => s.showAnchorsInEdit = false); 
                       }
                   }
                   activeCurve = { id: 'active_after_space_finalize', anchors: [], segments: [], showAnchorsInEdit: true }; 
                   isDrawingMode = false; 
                   updateFrameUI();
                   redrawCanvas();
                }
            }
        });

        canvas.addEventListener('wheel', (event) => {
            event.preventDefault(); 
            // Removed: if (isAnimating) return; -> Allows zoom during animation

            const mouseCanvasPos = getMouseCanvasPos(event); 
            const worldMouseX = (mouseCanvasPos.x - originX) / scaleFactor;
            const worldMouseY = (mouseCanvasPos.y - originY) / scaleFactor;
            
            const oldScaleFactor = scaleFactor; 
            let newScaleFactor = scaleFactor;
            if (event.deltaY < 0) { 
                newScaleFactor *= (1 + ZOOM_INTENSITY);
            } else { 
                newScaleFactor /= (1 + ZOOM_INTENSITY);
            }
            newScaleFactor = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScaleFactor));

            if (newScaleFactor !== scaleFactor) { 
                // Only save state for undo if not animating, or if an interaction (like drag for pan) is happening
                if (!isAnimating || draggedPointInfo !== null) {
                    saveStateForUndo();
                }
                scaleFactor = newScaleFactor;
                originX = mouseCanvasPos.x - worldMouseX * scaleFactor;
                originY = mouseCanvasPos.y - worldMouseY * scaleFactor;
                
                updateZoomIndicator(); 
                redrawCanvas();
            }
        });

        // --- Save/Load Functionality ---
        saveMovieButton.addEventListener('click', () => {
            if (isAnimating && draggedPointInfo === null) return;
            if (isDrawingMode && activeCurve.anchors.length > 0) { 
                 const currentFrameSequences = animationFrames[currentFrameIndex];
                 currentFrameSequences.push({
                    id: 'finalized_on_save_' + Date.now(),
                    anchors: [...activeCurve.anchors],
                    segments: [...activeCurve.segments],
                    showAnchorsInEdit: false 
                });
                activeCurve = {id: 'active_cleared_on_save', anchors: [], segments: [], showAnchorsInEdit: true};
                isDrawingMode = false;
                redrawCanvas(); 
            }

            const dataToSave = {
                animationFrames: animationFrames,
            };
            const jsonData = JSON.stringify(dataToSave); 
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); 
            a.href = url;
            a.download = 'animation.clp'; 
            document.body.appendChild(a);
            a.click(); 
            document.body.removeChild(a); 
            URL.revokeObjectURL(url); 
        });

        loadMovieInput.addEventListener('change', (event) => {
            if (isAnimating && draggedPointInfo === null) return;
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => { 
                    try {
                        const loadedData = JSON.parse(e.target.result);
                        if (loadedData && loadedData.animationFrames) {
                            animationFrames = rehydrateFrameData(loadedData.animationFrames);
                            currentFrameIndex = 0; 
                            activeCurve = { id: 'active_after_load', anchors: [], segments: [], showAnchorsInEdit: true };
                            isDrawingMode = false;
                            isEditModeActive = false;
                            scaleFactor = 1.0; 
                            originX = 0;
                            originY = 0;
                            undoStack = []; 
                            redoStack = [];
                            saveStateForUndo(); 
                            if(isAnimating) stopAnimation(); 
                            
                            updateFrameUI();
                            redrawCanvas();
                            console.log("Animation loaded successfully.");
                        } else {
                            alert("קובץ לא תקין או חסר נתונים.");
                        }
                    } catch (error) {
                        console.error("Error loading or parsing file:", error);
                        alert("שגיאה בטעינת הקובץ: " + error.message);
                    } finally {
                        loadMovieInput.value = ''; 
                    }
                };
                reader.onerror = () => { 
                    alert("שגיאה בקריאת הקובץ.");
                     loadMovieInput.value = '';
                };
                reader.readAsText(file); 
            }
        });
        
        clearCanvasButton.addEventListener('click', () => {
            if (isAnimating && draggedPointInfo === null) return;
            if (confirm("האם אתה בטוח שברצונך לנקות הכל ולהתחיל מחדש?")) {
                saveStateForUndo(); 
                
                animationFrames = [[]]; 
                currentFrameIndex = 0;
                activeCurve = { id: 'active_cleared_' + Date.now(), anchors: [], segments: [], showAnchorsInEdit: true };
                isDrawingMode = false;
                isEditModeActive = false; 
                scaleFactor = 1.0;    
                originX = 0;          
                originY = 0;
                
                updateFrameUI();    
                redrawCanvas();     
            }
        });


        undoButton.addEventListener('click', performUndo);
        redoButton.addEventListener('click', performRedo);
        
        initializeAppOnLoad(); 
    </script>
</body>
</html>
